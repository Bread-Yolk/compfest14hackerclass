# Binary Exploitation Is Ez

> Write-up author: jon-brandy (SOLVED)

## DESKRIPSI:
Take a break, here's an easy problem

`nc 103.185.38.238 15733`.

## LANGKAH-LANGKAH:
1. Pertama, unduh file `.zip` yang diberikan.
2. Lalu unzip file tersebut.

> HASIL

![image](https://user-images.githubusercontent.com/70703371/185915611-1fe7b5e3-1657-4458-ac2b-f52226ab84e4.png)

3. Selanjutnya, cek file program `ez` yang diberikan.

> NOTES

```
Jalankan -> file ez dan checksec --file ez
```

> OUTPUT 

![image](https://user-images.githubusercontent.com/70703371/185915855-b5245817-288b-4e9b-83cb-9b6c4163ac41.png)

![image](https://user-images.githubusercontent.com/70703371/185915909-84d1736a-25f6-4344-b707-d71699443658.png)

4. Nampaknya, file *not stripped* (menandakan kita masih dapat melihat fungsi pada source-code) dan tidak ada protektor PIE (menandakan memory yang tersimpan tidak akan berubah).
5. Selanjutnya saya melakukan pengecekan pada source-code.

> ez.c

```c

#include<stdio.h>
#include<stdlib.h>

struct meme
{
	void (*func)(char*);
	char* content;
};


struct meme** memes;


void init()	{
	setvbuf(stdout, NULL, _IONBF, 0);
	memes = malloc(8 * sizeof(void *));
}

unsigned int read_int()	{
	char buf[16];
	fgets(buf, 16, stdin);
	return strtoul(buf, NULL, 10);
}

void print_menu()	{
	puts("===Meme Creator===");
	puts("1. New Meme");
	puts("2. Edit Meme");
	puts("3. Print Meme");
	puts("4. Exit");
	puts("==================");
	printf("Choice: ");
}

void EZ_WIN()	{
	puts("EAAAAAAAAAAAASYYYYYYYYYYYYY");
	system("/bin/sh");
	exit(0);
}

void my_print(char* buf)	{
	printf("Content: %s\n", buf);
}

void new_meme()	{
	unsigned int size;
	printf("Enter meme size: ");
	size = read_int();
	if(size > 0x200)	{
		puts("Please, noone wants to read the entire bee movie script");
		exit(-1);
	}
	int i = 0;
	while(memes[i] != NULL && ++i < 8);
	if(i == 8)	{
		puts("No more memes for you!");
		exit(-1);
	}
	memes[i] = malloc(8);
	memes[i]->func = &my_print;
	memes[i]->content = malloc(size);
	printf("Enter meme content: ");
	fgets(memes[i]->content, size, stdin);
	puts("Done!");
}

void edit_meme()	{
	unsigned int idx;
	printf("Index: ");
	idx = read_int();
	if(memes[idx] == NULL)	{
		puts("There's no meme there!");
		return;
	}
	printf("Enter meme content: ");
	gets(memes[idx]->content);
	puts("Done!");
}

void print_meme()	{
	unsigned int idx;
	printf("Index: ");
	idx = read_int();
	if(memes[idx] == NULL)	{
		puts("There's no meme there!");
		return;
	}
	(*(memes[idx]->func))(memes[idx]->content);
}

int main(int argc, char const *argv[])
{
	unsigned int choice;

	init();
	while(1)	{
		print_menu();
		choice = read_int();
		switch(choice)	{
			case 1:
				new_meme();
				break;
			case 2:
				edit_meme();
				break;
			case 3:
				print_meme();
				break;	
			case 4:
				puts("Bye bye!");
				exit(0);
				break;
			default:
				puts("Invalid choice!");
				break;
		}
	}
	return 0;
}
```

6. Setelah di analisis, sepertinya kita dapat memanfaatkan vuln dari fungsi `edit_meme` dikarenakan terdapat pemanggilan fungsi `gets`.

> NOTES

```
Melakukan buffer overflow sehingga mengoverwrite variable func sehingga memiliki address dari fungsi EZ_WIN()
```

> FUNGSI EDIT_MEME()

![image](https://user-images.githubusercontent.com/70703371/185917424-981dc78e-908d-45f5-94d0-dee55a0b2af2.png)

7. Diketahui pada fungsi `print_meme` akan memberikan output dari fungsi EZ_WIN() yang telah ditulis addressnya.

![image](https://user-images.githubusercontent.com/70703371/185918169-ceec300c-ea7b-49e6-960c-37cd7ac062c0.png)

> STRUCT

![image](https://user-images.githubusercontent.com/70703371/185918264-959cdbbb-f27d-441e-8966-4933b612e787.png)

8. Konsep yang akan diterapkan disini yaitu `buffer overflow`, `ret2win`, dan `basic heap`.

## REFERENCES:

```
https://www.imperva.com/learn/application-security/buffer-overflow/
https://www.youtube.com/c/CyberSecurityIPB
https://int0x33.medium.com/day-1-rop-emporium-ret2win-64bit-bb0d1893a3b0
https://ctf101.org/binary-exploitation/heap-exploitation/
https://infosecwriteups.com/into-the-art-of-binary-exploitation-0x000001-stack-based-overflow-50fe48d58f10
```


